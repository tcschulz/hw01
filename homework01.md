#CSCI 5828: Homework 1
#Tanya Schulz

The purpose of this assignment is to review and develop understanding of the concepts and ideas explored by Frederick P. Brooks's article, No Silver Bullet. Aristotle's reputable works catalyzed metaphysics, the branch of philosophy regarding principles of being, knowing, and space. He theorized the overarching structure of existence with the question, "What does 'is' mean?" Over the course of his works, Aristotle deduced that every "thing" has accidential and essential properties. He proposed a distinction between reality and how reality is perceived, which he categorized as essence and accident. According to Aristotle's treatise, "substance" is something that exists naturally without dependence on anything else. A rock exists in its own right, and does not exist in something else. In contrast, an "accident" exists in or due to something else [1]. His most notable examples for accident and substance were the color "white" and "Socrates". White is used in context as belonging to other things, and not existing alone, "This thing is Socrates" is different because Socrates does not exist as part of "thing thing", rather Socrates "is the thing" [2]. Brooks's article "No Silver Bullet: Essence and Accidents of Software Engineering" utilizes Aristotle's philosophy to investigates the difficulties involved software engineering. Brooks similarly divides the difficulties with software engineering into two cateogries, "essential difficulties" and "accidental difficulties". 

1.  Brooks uses the term "essential difficulties" to describe problems in software engineering that arise due to the nature of software. Similar to Aristotle's definition of substance, essential difficulties exist on their own and not as an entity of another thing. Brooks states that these are difficulties which are, "inherent in the nature of software", and are constructs by which all other concepts are unlocked. In other words, direct solutions for essential difficulties do not and cannot exist, because they are instrinsic to software.  Following Aristotle's model, essential difficulties exist on their own as their own entity. An example of an essential difficulty in software engineering is when an operating system becomes outdated, applications that were designed for that operating system must change with the new technology. 

2.  On the other hand, "accidental difficulties" are not inherent to software engineering, but arise in the production process of software. It is important to note that these difficulties do not occur by chance, as the definition of accident might imply. Accidental difficulties occur during software development in the general relationship that using a particular method to achieve a desired functionality results in an undesired problem. Unlike essential difficulties, solutions generally exist for accidential difficulties, even though Brooks notes that there are naturally limits to overcoming these. Examination of significant developments in software technology reflects this characteristic of accidental difficulties. Brooks provides the example of how integrating programming environments for widespread use was attacked. He states that "Unix and Interlisp, the first integrated programming environments to come into widespread use, seem to have improved productivity by integral factors" by "using individual programs together, by providing integrated libraries, unified file formats, and pipes and filters." Another basic example of an accidental difficulty is configuring a program to run on a 32-bit system when it was supposed to be compatible for 64-bit. 

3.  According to Brooks, the four essential difficulties of developing software are: complexity, comformity, changeability, and invisibility. Brooks defines each of these types as follows:

	a) **Complexity**
	The relationship between the size of a software entity is not directly proportional to its complexity due to the 		fact that no two parts are the same, with the exception of statements. Unlike common physical constructs, 	such as buildings or cars, the size of a software system is not an indication of its magnitude of complexity. 	Brooks puts this essential difficulty into context by making a comparison to digital computers. Software 		systems are orders of magnitude more complicated than digital computers, one of the most complex things 		humans have built. He explains that digital computers "have a very large number of states", which "makes 	conceiving, describing, and testing them hard." For example, as the size of a software system increases, the 		relationships between software components such as code, documents, and specifications create even more 	complexity.
	
	b) **Conformity**
	Conformity is an essential difficulty in software engineering due to "arbitrary complexity", or uncertainty that cannot be predicted. Software is constantly adapting, changing, and facing  In software engineering, the components are many different systems, interfaces, regulations, methods, There are many different systems, interfaces, opinions, regulations, and other core components of software 
	
	c) **Changeability**
	Software is incessantly pressured to change. The main component of software is function, and the pressure to change arises from the demand to adjust and improve functionality. Software is connected to a dynamic matrix of "applications, users, laws, and machine vehicles" by which it is forced to change to meet this chain of other changes. Even successful software changes, due in part to the never-ending demand for increase in functionality and develop more ways it can be used. For example, software cannot remain unaltered when there is new technology, such as printers or computers. It can only survice past the machine or system that it was originally designed to accompany.
	
	d) **Invisibility** 
	Human senses (sight, hearing, touch, etc.) cannot detect or visualize what does not belong to the tangible 3D eulerian world. Thus, software is inherently invisble, while humans inherently rely on their senses to comprehend what they are designing and producing. This forces software engineers to utilize less brain power to conceptualize the structures of software. In contrast to blue prints, geometry and diagrams cannot be used to identify problems or control use of space in software. When attempts are made to diagram or visually represent software, multiple results are generated because there is generally not a set hierarchy that the software structure must meet. While conceptual control over software structure can be reduced by enforced link cutting, software still consists of multiple graphs superimposed on each other. Common graphs like time sequence, data flow, and name-space relationships are "usually not even planar, much less heirarchial."

4.  Brook's particularly verbose definition of a silver bullet emerges from the quote, "single development, in either technology or in management technique, that by itself promises even one order-of-magnitude improvement in productivity, in reliability, in simplicity." In other words, a silver bullet is a solution consisting of a single method or implementation of a technique that solves many problems at once, improving the overall productivity, reliability, and simplicity of software by orders of magnitude. 

5.  The analogy utilized in class to describe the difference between software engineering and computer science was the comparison of a chemist to a chemical engineer. A chemist is a scientist who specializes in chemistry, or the study of all matter (i.e. structures and compositions of compounds, ions, atoms, bonding energy). Chemical engineers apply the knowledge and works developed by chemists for a certain purpose. For example, a chemical engineer might use a material developed or discovered by a chemist to improve a particular aspect of manufacturing, design, or marketing. Following the previous anaolgy, software is computer programs and their components (documents, test cases, guidelines), while software engineering applies practical numerical and scientific knowledge to develop software. 

6.  Five concepts that are important to software engineers include abstractations, conversations, specification, translation, and iteration. Each concept's definition and importance to software engineers are detailed in the following list.

    1.  **Abstractions** are the techniques used for organizing and presenting systems. Examples presented in lecture notes from class are file systems, databases, and mobile application API's. Abstractations are how software engineers break down the problem into something more simple and understandable. 

    2.  **Conversations** are how ideas are communicated between multiple individuals or groups. Conversations are requisite in software engineering for comprehending the scope of the problem being solved, learning other developers' work, and setting design goals. One of the most common examples of this is online documentation for downloading, installing, and using a computer program. 
    
    3.  **Specifications** are limits or standards that define a target value or metric to be met in   developing a product. Specifications are, more or less, requirements that the final product must meet. In software engineering, everything must be specified so that the product meets a specific function. Some examples used in class are code, test plans, development cycles, and design.
    
    4.  **Translation** is defined as moving something from one place to another. While this is a broad definition, especially with the use of the word "place", it is important for the progress of software engineering. To illustrate, an initial idea can be translated to a requirement, then translated to certain structure, then translated to a file system, and so on. 
    
    5.  **Iteration** is the process of repeating a procedure methodologically until a desired result is achieved. To explain, a procedure is repeated to improve and build upon the previous procudure for achieving optimal results. One of the most basic examples of iteration is when a successful program is released, newer version are released periodically to improve bugs or increase functionality. 

[1] http://www.aquinasonline.com/Topics/substacc.html
[2] https://plato.stanford.edu/entries/aristotle-metaphysics/#Cate
[3] Brooks. “No Silver Bullet Essence and Accidents of Software 		Engineering.” Computer, vol. 20, no. 4, 1987, pp. 10–19., doi:10.1109/mc.1987.1663532. 






